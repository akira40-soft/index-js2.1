/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ADVANCED PENTESTING TOOLKIT - REAL TOOLS v2
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ… NMAP - Port scanning real (github.com/nmap/nmap)
 * âœ… SQLMAP - SQL injection real (github.com/sqlmapproject/sqlmap)
 * âœ… Hydra - Password cracking (github.com/vanhauser-thc/thc-hydra)
 * âœ… Nuclei - Vulnerability scanning (github.com/projectdiscovery/nuclei)
 * âœ… Masscan - Fast port scanner (github.com/robertdavidgraham/masscan)
 * âœ… Nikto - Web server scanner (github.com/sullo/nikto)
 * 
 * TODAS AS FERRAMENTAS SÃƒO REAIS E BAIXADAS NO DOCKERFILE.RAILWAY
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

const { spawn, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class AdvancedPentestingToolkit {
  constructor(config = {}) {
    this.config = config;
    
    // Caminhos das ferramentas - devem corresponder ao Dockerfile.railway
    this.tools = {
      nmap: '/usr/bin/nmap',
      sqlmap: '/opt/sqlmap/sqlmap.py',
      hydra: '/usr/bin/hydra',
      nuclei: '/usr/local/bin/nuclei',
      masscan: '/usr/local/bin/masscan',
      nikto: '/usr/bin/nikto'
    };
    
    this.resultsDir = config.resultsDir || '/tmp/pentest_results';
    
    // Criar diretÃ³rio de resultados
    if (!fs.existsSync(this.resultsDir)) {
      fs.mkdirSync(this.resultsDir, { recursive: true });
    }
    
    // Verificar ferramentas disponÃ­veis
    this.availableTools = this._checkAvailableTools();
    
    console.log('âœ… AdvancedPentestingToolkit inicializado');
    console.log(`   ðŸ“¦ Ferramentas disponÃ­veis: ${Object.keys(this.availableTools).filter(k => this.availableTools[k]).length}/6`);
  }

  /**
   * Verifica quais ferramentas estÃ£o disponÃ­veis
   */
  _checkAvailableTools() {
    const available = {};
    
    for (const [name, toolPath] of Object.entries(this.tools)) {
      try {
        // Verifica se o arquivo existe
        if (fs.existsSync(toolPath)) {
          // Tenta executar para confirmar que funciona
          const checkCmd = name === 'sqlmap' 
            ? `python3 ${toolPath} --version`
            : `${toolPath} --version`;
          
          execSync(checkCmd, { stdio: 'pipe', timeout: 5000 });
          available[name] = true;
          console.log(`   âœ… ${name}: ${toolPath}`);
        } else {
          available[name] = false;
          console.warn(`   âŒ ${name}: ${toolPath} (nÃ£o encontrado)`);
        }
      } catch (e) {
        available[name] = false;
        console.warn(`   âŒ ${name}: ${toolPath} (erro: ${e.message})`);
      }
    }
    
    return available;
  }

  /**
   * Verifica se uma ferramenta especÃ­fica estÃ¡ disponÃ­vel
   */
  _isToolInstalled(toolName) {
    return this.availableTools[toolName] === true;
  }

  /**
   * Retorna status das ferramentas
   */
  getToolsStatus() {
    return {
      ...this.availableTools,
      resultsDir: this.resultsDir,
      allInstalled: Object.values(this.availableTools).every(v => v)
    };
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ðŸ” NMAP - Port Scanning REAL
   * GitHub: https://github.com/nmap/nmap
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async nmapScan(target, opcoes = '-sV -A -O') {
    try {
      if (!this._isTargetValid(target)) {
        return { sucesso: false, erro: 'Alvo invÃ¡lido' };
      }

      console.log(`ðŸ” Iniciando NMAP scan em: ${target}`);

      // Verifica se nmap estÃ¡ instalado
      if (!this._isToolInstalled('nmap')) {
        return { 
          sucesso: false, 
          erro: 'NMAP nÃ£o estÃ¡ instalado. Verifique Dockerfile.railway.',
          ferramenta: 'nmap',
          caminhoEsperado: this.tools.nmap,
          instalado: false
        };
      }

      return new Promise((resolve, reject) => {
        const args = opcoes.split(' ').concat(target);
        const nmap = spawn(this.tools.nmap, args);

        let output = '';
        let error = '';

        nmap.stdout.on('data', (data) => output += data.toString());
        nmap.stderr.on('data', (data) => error += data.toString());

        nmap.on('close', (code) => {
          if (code === 0) {
            const resultado = {
              sucesso: true,
              tipo: 'nmap_scan',
              target,
              comando: `${this.tools.nmap} ${opcoes} ${target}`,
              output: output,
              parsado: this._parseNmapOutput(output),
              timestamp: new Date().toISOString(),
              risco: this._calculateNmapRisk(output),
              openPorts: this._extractOpenPorts(output)
            };

            // Salvar resultado
            this._saveResult('nmap', target, resultado);

            resolve(resultado);
          } else {
            reject({
              sucesso: false,
              erro: error || 'NMAP failed',
              code,
              target
            });
          }
        });

        // Timeout de 10 minutos
        setTimeout(() => {
          nmap.kill();
          reject({ erro: 'NMAP timeout', target });
        }, 600000);
      });
    } catch (e) {
      console.error('Erro em nmapScan:', e);
      return { sucesso: false, erro: e.message };
    }
  }

  _extractOpenPorts(output) {
    const ports = [];
    const lines = output.split('\n');

    for (const line of lines) {
      const match = line.match(/(\d+)\/tcp\s+(\w+)\s+(.+)/);
      if (match && match[2] === 'open') {
        ports.push({
          port: match[1],
          protocol: 'tcp',
          service: match[3].trim()
        });
      }
    }

    return ports;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ðŸ’¾ SQLMAP - SQL Injection REAL
   * GitHub: https://github.com/sqlmapproject/sqlmap
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async sqlmapTest(url, parametro = 'id', opcoes = '--risk=1 --level=1 --batch') {
    try {
      if (!this._isUrlValid(url)) {
        return { sucesso: false, erro: 'URL invÃ¡lida' };
      }

      console.log(`ðŸ’¾ Iniciando SQLMAP test em: ${url}`);

      // Verifica se sqlmap estÃ¡ instalado
      if (!this._isToolInstalled('sqlmap')) {
        return { 
          sucesso: false, 
          erro: 'SQLMAP nÃ£o estÃ¡ instalado. Verifique Dockerfile.railway.',
          ferramenta: 'sqlmap',
          caminhoEsperado: this.tools.sqlmap,
          instalado: false
        };
      }

      return new Promise((resolve, reject) => {
        const args = [
          this.tools.sqlmap,
          '-u', url,
          '-p', parametro,
          '--dbs',
          ...opcoes.split(' ')
        ];

        const sqlmap = spawn('python3', args);

        let output = '';
        let error = '';

        sqlmap.stdout.on('data', (data) => output += data.toString());
        sqlmap.stderr.on('data', (data) => error += data.toString());

        sqlmap.on('close', (code) => {
          const vulnerable = output.includes('vulnerable') || output.includes('is vulnerable');
          const databases = this._extractDatabases(output);
          
          const resultado = {
            sucesso: code === 0 || vulnerable,
            tipo: 'sqlmap_test',
            target: url,
            parametro,
            vulnerable,
            databases,
            output: output.substring(0, 5000), // Limita tamanho
            timestamp: new Date().toISOString(),
            risco: vulnerable ? 'CRÃTICO' : 'BAIXO'
          };

          // Salvar resultado
          this._saveResult('sqlmap', url, resultado);

          resolve(resultado);
        });

        // Timeout de 15 minutos
        setTimeout(() => {
          sqlmap.kill();
          resolve({
            sucesso: false,
            erro: 'SQLMAP timeout',
            target: url
          });
        }, 900000);
      });
    } catch (e) {
      console.error('Erro em sqlmapTest:', e);
      return { sucesso: false, erro: e.message };
    }
  }

  _extractDatabases(output) {
    const databases = [];
    const lines = output.split('\n');
    let foundHeader = false;
    
    for (const line of lines) {
      if (line.includes('available databases')) {
        foundHeader = true;
        continue;
      }
      if (foundHeader && line.includes('[') && line.includes(']')) {
        const match = line.match(/\[\w+\]\s*(\w+)/);
        if (match) databases.push(match[1]);
      }
      if (foundHeader && databases.length >= 5) break;
    }
    
    return databases;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ðŸ” HYDRA - Password Cracking REAL
   * GitHub: https://github.com/vanhauser-thc/thc-hydra
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async hydraBrute(target, servico = 'ssh', usuario = 'admin', senhas = ['password', 'admin', '123456']) {
    try {
      console.log(`ðŸ” Iniciando Hydra brute force: ${servico}://${target}`);

      // Verifica se hydra estÃ¡ instalado
      if (!this._isToolInstalled('hydra')) {
        return { 
          sucesso: false, 
          erro: 'Hydra nÃ£o estÃ¡ instalado. Verifique Dockerfile.railway.',
          ferramenta: 'hydra',
          caminhoEsperado: this.tools.hydra,
          instalado: false
        };
      }

      return new Promise((resolve, reject) => {
        // Criar arquivo temporÃ¡rio com senhas
        const passwordFile = path.join(this.resultsDir, `passwords_${Date.now()}.txt`);
        fs.writeFileSync(passwordFile, senhas.join('\n'));

        const args = [
          '-l', usuario,
          '-P', passwordFile,
          '-o', path.join(this.resultsDir, `hydra_${target}_${servico}.txt`),
          target,
          servico,
          '-f' // Sair apÃ³s primeira tentativa bem-sucedida
        ];

        const hydra = spawn(this.tools.hydra, args);

        let output = '';
        let foundPassword = null;

        hydra.stdout.on('data', (data) => {
          const chunk = data.toString();
          output += chunk;
          const passMatch = chunk.match(/password:\s*(\S+)/);
          if (passMatch) foundPassword = passMatch[1];
        });

        hydra.on('close', (code) => {
          // Limpar arquivo temporÃ¡rio
          try { fs.unlinkSync(passwordFile); } catch (e) {}

          const resultado = {
            sucesso: code === 0 || foundPassword !== null,
            tipo: 'hydra_brute',
            target,
            servico,
            usuario,
            found: foundPassword !== null,
            password: foundPassword,
            output: output.substring(0, 2000),
            timestamp: new Date().toISOString()
          };

          // Salvar resultado
          this._saveResult('hydra', `${servico}://${target}`, resultado);

          resolve(resultado);
        });

        setTimeout(() => {
          hydra.kill();
          resolve({
            sucesso: false,
            erro: 'Hydra timeout',
            target,
            servico
          });
        }, 600000); // 10 minutos
      });
    } catch (e) {
      console.error('Erro em hydraBrute:', e);
      return { sucesso: false, erro: e.message };
    }
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ðŸŽ¯ NUCLEI - Vulnerability Scanning REAL
   * GitHub: https://github.com/projectdiscovery/nuclei
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async nucleiScan(target, templates = 'cves') {
    try {
      if (!this._isTargetValid(target)) {
        return { sucesso: false, erro: 'Alvo invÃ¡lido' };
      }

      console.log(`ðŸŽ¯ Iniciando Nuclei scan em: ${target}`);

      // Verifica se nuclei estÃ¡ instalado
      if (!this._isToolInstalled('nuclei')) {
        return { 
          sucesso: false, 
          erro: 'Nuclei nÃ£o estÃ¡ instalado. Verifique Dockerfile.railway.',
          ferramenta: 'nuclei',
          caminhoEsperado: this.tools.nuclei,
          instalado: false
        };
      }

      return new Promise((resolve, reject) => {
        const args = [
          '-target', target,
          '-templates', templates,
          '-severity', 'critical,high,medium',
          '-json',
          '-o', path.join(this.resultsDir, `nuclei_${target.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.json`)
        ];

        const nuclei = spawn(this.tools.nuclei, args);

        let output = '';
        let jsonOutput = '';
        const findings = [];

        nuclei.stdout.on('data', (data) => {
          const chunk = data.toString();
          output += chunk;
          jsonOutput += chunk;
        });

        nuclei.on('close', (code) => {
          // Parse JSON output
          try {
            const lines = jsonOutput.trim().split('\n');
            for (const line of lines) {
              if (line.trim()) {
                try {
                  const parsed = JSON.parse(line);
                  if (parsed && parsed.template) {
                    findings.push({
                      name: parsed.template || 'Unknown',
                      severity: parsed.severity || 'unknown',
                      cvss: parsed.cvss_metrics || null,
                      url: parsed.host || target,
                      matcher: parsed.matcher_name || null
                    });
                  }
                } catch (e) {}
              }
            }
          } catch (e) {}

          const resultado = {
            sucesso: code === 0 || findings.length > 0,
            tipo: 'nuclei_scan',
            target,
            templates,
            findings: findings.slice(0, 50),
            totalFindings: findings.length,
            timestamp: new Date().toISOString(),
            risco: findings.filter(f => f.severity === 'critical').length > 0 ? 'CRÃTICO' : 
                   findings.length > 0 ? 'MÃ‰DIO' : 'BAIXO'
          };

          // Salvar resultado
          this._saveResult('nuclei', target, resultado);

          resolve(resultado);
        });

        setTimeout(() => {
          nuclei.kill();
          resolve({
            sucesso: false,
            erro: 'Nuclei timeout',
            target
          });
        }, 900000); // 15 minutos
      });
    } catch (e) {
      console.error('Erro em nucleiScan:', e);
      return { sucesso: false, erro: e.message };
    }
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * âš¡ MASSCAN - Fast Port Scanner REAL
   * GitHub: https://github.com/robertdavidgraham/masscan
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async masscanScan(target, portas = '1-65535') {
    try {
      if (!this._isTargetValid(target)) {
        return { sucesso: false, erro: 'Alvo invÃ¡lido' };
      }

      console.log(`âš¡ Iniciando Masscan em: ${target}`);

      // Verifica se masscan estÃ¡ instalado
      if (!this._isToolInstalled('masscan')) {
        return { 
          sucesso: false, 
          erro: 'Masscan nÃ£o estÃ¡ instalado. Verifique Dockerfile.railway.',
          ferramenta: 'masscan',
          caminhoEsperado: this.tools.masscan,
          instalado: false
        };
      }

      return new Promise((resolve, reject) => {
        const args = [
          '-p', portas,
          target,
          '--rate', '1000',
          '-oJ', path.join(this.resultsDir, `masscan_${target.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.json`)
        ];

        const masscan = spawn(this.tools.masscan, args);

        let output = '';

        masscan.stdout.on('data', (data) => output += data.toString());

        masscan.on('close', (code) => {
          const openPorts = this._parseMasscanJson(output);
          
          const resultado = {
            sucesso: code === 0 || openPorts.length > 0,
            tipo: 'masscan_scan',
            target,
            portas,
            openPorts,
            output: output.substring(0, 2000),
            timestamp: new Date().toISOString()
          };

          // Salvar resultado
          this._saveResult('masscan', target, resultado);

          resolve(resultado);
        });

        setTimeout(() => {
          masscan.kill();
          resolve({
            sucesso: false,
            erro: 'Masscan timeout',
            target
          });
        }, 600000); // 10 minutos
      });
    } catch (e) {
      console.error('Erro em masscanScan:', e);
      return { sucesso: false, erro: e.message };
    }
  }

  _parseMasscanJson(output) {
    const ports = [];
    try {
      // Tenta parsear como JSON
      const jsonMatch = output.match(/\[(.*)\]/s);
      if (jsonMatch) {
        const jsonStr = '[' + jsonMatch[1] + ']';
        const data = JSON.parse(jsonStr);
        if (Array.isArray(data)) {
          for (const item of data) {
            if (item.port) {
              ports.push({
                port: item.port,
                protocol: item.proto || 'tcp',
                status: 'open'
              });
            }
          }
        }
      }
    } catch (e) {}
    return ports;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ðŸ•·ï¸ NIKTO - Web Server Scanner REAL
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async niktoScan(url, opcoes = '') {
    try {
      if (!this._isUrlValid(url)) {
        return { sucesso: false, erro: 'URL invÃ¡lida' };
      }

      console.log(`ðŸ•·ï¸ Iniciando Nikto scan em: ${url}`);

      // Verifica se nikto estÃ¡ instalado
      if (!this._isToolInstalled('nikto')) {
        return { 
          sucesso: false, 
          erro: 'Nikto nÃ£o estÃ¡ instalado. Verifique Dockerfile.railway.',
          ferramenta: 'nikto',
          caminhoEsperado: this.tools.nikto,
          instalado: false
        };
      }

      return new Promise((resolve, reject) => {
        const args = [
          '-h', url,
          '-o', path.join(this.resultsDir, `nikto_${url.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.txt`),
          ...opcoes.split(' ').filter(x => x)
        ];

        const nikto = spawn(this.tools.nikto, args);

        let output = '';

        nikto.stdout.on('data', (data) => output += data.toString());

        nikto.on('close', (code) => {
          const issues = this._parseNiktoOutput(output);
          
          const resultado = {
            sucesso: code === 0 || issues.length > 0,
            tipo: 'nikto_scan',
            target: url,
            issues,
            output: output.substring(0, 5000),
            timestamp: new Date().toISOString(),
            vulnerabilities: issues
          };

          // Salvar resultado
          this._saveResult('nikto', url, resultado);

          resolve(resultado);
        });

        setTimeout(() => {
          nikto.kill();
          resolve({
            sucesso: false,
            erro: 'Nikto timeout',
            target: url
          });
        }, 600000); // 10 minutos
      });
    } catch (e) {
      console.error('Erro em niktoScan:', e);
      return { sucesso: false, erro: e.message };
    }
  }

  _parseNiktoOutput(output) {
    const issues = [];
    const lines = output.split('\n');

    for (const line of lines) {
      if (line.includes('+') || line.includes('OSVDB') || line.includes('CVE')) {
        const cleaned = line.replace(/^\s*\+\s*/, '').trim();
        if (cleaned && cleaned.length > 5) {
          issues.push({
            description: cleaned,
            severity: line.includes('OSVDB') || line.includes('CVE') ? 'HIGH' : 'MEDIUM'
          });
        }
      }
    }

    return issues.slice(0, 20);
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * FUNÃ‡Ã•ES AUXILIARES PRIVADAS
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */

  _parseNmapOutput(output) {
    const portas = [];
    const lines = output.split('\n');

    for (const line of lines) {
      const match = line.match(/(\d+)\/tcp\s+(\w+)\s+(.+)/);
      if (match) {
        portas.push({
          porta: match[1],
          protocolo: 'tcp',
          estado: match[2],
          servico: match[3].trim(),
          risco: ['open', 'filtered'].includes(match[2]) ? 'MÃ‰DIO' : 'BAIXO'
        });
      }
    }

    return {
      totalPortas: portas.length,
      portasAbertas: portas.filter(p => p.estado === 'open').length,
      portas
    };
  }

  _calculateNmapRisk(output) {
    const lines = output.split('\n');
    const portasAbertas = lines.filter(line => line.includes('open')).length;

    if (portasAbertas > 10) return 'CRÃTICO';
    if (portasAbertas > 5) return 'ALTO';
    if (portasAbertas > 0) return 'MÃ‰DIO';
    return 'BAIXO';
  }

  _isTargetValid(target) {
    return /^[\d.]+$/.test(target) || /^[\w.-]+$/.test(target);
  }

  _isUrlValid(url) {
    try {
      new URL(url);
      return true;
    } catch (e) {
      return false;
    }
  }

  _saveResult(tool, target, resultado) {
    try {
      const safeTarget = target.replace(/[^a-z0-9]/g, '_').substring(0, 50);
      const filename = path.join(
        this.resultsDir,
        `${tool}_${safeTarget}_${Date.now()}.json`
      );

      fs.writeFileSync(filename, JSON.stringify(resultado, null, 2));
      console.log(`âœ… Resultado salvo: ${filename}`);
    } catch (e) {
      console.warn(`âš ï¸ Erro ao salvar resultado: ${e.message}`);
    }
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ðŸ“Š RELATÃ“RIO COMBINADO
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  async generateComprehensiveReport(target) {
    try {
      console.log(`\nðŸ“Š Gerando relatÃ³rio completo para: ${target}\n`);

      const relatorio = {
        alvo: target,
        dataInicio: new Date().toISOString(),
        ferramentas: {},
        resumo: {},
        recomendacoes: []
      };

      // 1. NMAP
      if (this._isToolInstalled('nmap')) {
        console.log('1ï¸âƒ£  Executando NMAP...');
        try {
          const nmapResult = await this.nmapScan(target, '-sV -A');
          relatorio.ferramentas.nmap = nmapResult;
        } catch (e) {
          relatorio.ferramentas.nmap = { erro: e.message };
        }
      }

      // 2. MASSCAN (mais rÃ¡pido)
      if (this._isToolInstalled('masscan')) {
        console.log('2ï¸âƒ£  Executando Masscan...');
        try {
          const masscanResult = await this.masscanScan(target, '1-10000');
          relatorio.ferramentas.masscan = masscanResult;
        } catch (e) {
          relatorio.ferramentas.masscan = { erro: e.message };
        }
      }

      // 3. NUCLEI
      if (this._isToolInstalled('nuclei')) {
        console.log('3ï¸âƒ£  Executando Nuclei...');
        try {
          const nucleiResult = await this.nucleiScan(target);
          relatorio.ferramentas.nuclei = nucleiResult;
        } catch (e) {
          relatorio.ferramentas.nuclei = { erro: e.message };
        }
      }

      // 4. NIKTO
      if (this._isToolInstalled('nikto') && target.startsWith('http')) {
        console.log('4ï¸âƒ£  Executando Nikto...');
        try {
          const niktoResult = await this.niktoScan(target);
          relatorio.ferramentas.nikto = niktoResult;
        } catch (e) {
          relatorio.ferramentas.nikto = { erro: e.message };
        }
      }

      relatorio.dataFim = new Date().toISOString();
      relatorio.resumo = this._generateSummary(relatorio);

      console.log('\nâœ… RelatÃ³rio Completo Gerado!\n');

      return relatorio;
    } catch (e) {
      console.error('Erro ao gerar relatÃ³rio:', e);
      return { erro: e.message, alvo: target };
    }
  }

  _generateSummary(relatorio) {
    const ferramentas = relatorio.ferramentas || {};
    const sucessos = Object.values(ferramentas).filter(f => f && f.sucesso).length;
    
    let totalVulns = 0;
    for (const ferramenta of Object.values(ferramentas)) {
      if (ferramenta && ferramenta.findings) {
        totalVulns += ferramenta.findings.length;
      }
      if (ferramenta && ferramenta.issues) {
        totalVulns += ferramenta.issues.length;
      }
      if (ferramenta && ferramenta.openPorts) {
        totalVulns += ferramenta.openPorts.length;
      }
    }

    return {
      totalFerramentas: Object.keys(ferramentas).length,
      sucessos: sucessos,
      vulnerabilidades: totalVulns,
      ferramentasDisponiveis: Object.keys(this.availableTools).filter(k => this.availableTools[k]).length
    };
  }
}

module.exports = AdvancedPentestingToolkit;
