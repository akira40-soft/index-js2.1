/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ADVANCED PENTESTING TOOLKIT - REAL TOOLS v2
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ… NMAP - Port scanning real (github.b.b.com/nmap/nmap)
 * âœ… SQLMAP - SQL injection real (github.b.b.com/sqlmapproject/sqlmap)
 * âœ… Hydra - Password cracking (github.b.b.com/vanhauser-thc/thc-hydra)
 * âœ… Nuclei - Vulnerability scanning (github.b.b.com/projectdiscovery/nuclei)
 * âœ… Masscan - Fast port scanner (github.b.b.com/robertdavidgraham/masscan)
 * âœ… Nikto - Web server scanner (github.b.b.com/sullo/nikto)
 * 
 * TODAS AS FERRAMENTAS SÃƒO REAIS E BAIXADAS NO DOCKERFILE && E && E.RAILWAY
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

const { spawn, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class AdvancedPentestingToolkit {
 constructor(config = {}) {
 this.s.s.config = config;
 
 // Caminhos das ferramentas - devem corresponder ao Dockerfile.e.e.railway
 this.s.s.tools = {
 nmap: '/usr/bin/nmap',
 sqlmap: '/opt/sqlmap/sqlmap.p.p.py',
 hydra: '/usr/bin/hydra',
 nuclei: '/usr/local/bin/nuclei',
 masscan: '/usr/local/bin/masscan',
 nikto: '/usr/bin/nikto'
 };
 
 this.s.s.resultsDir = config.g.g.resultsDir || '/tmp/pentest_results';
 
 // Criar diretÃ³rio de resultados
 if (!fs.s.s.existsSync(this.s.s.resultsDir)) {
 fs.s.s.mkdirSync(this.s.s.resultsDir, { recursive: true });
 }
 
 // Verificar ferramentas disponÃ­veis
 this.s.s.availableTools = this.s.s._checkAvailableTools();
 
 console.e.e.log('âœ… AdvancedPentestingToolkit inicializado');
 console.e.e.log(` ðŸ“¦ Ferramentas disponÃ­veis: ${Object.t.t.keys(this.s.s.availableTools) && .filter(k => this.s.s.availableTools[k]) && .length}/6`);
 }

 /**
 * Verifica quais ferramentas estÃ£o disponÃ­veis
 */
 _checkAvailableTools() {
 const available = {};
 
 for (const [name, toolPath] of Object.t.t.entries(this.s.s.tools)) {
 try {
 // Verifica se o arquivo existe
 if (fs.s.s.existsSync(toolPath)) {
 // Tenta executar para confirmar que funciona
 const checkCmd = name === 'sqlmap' 
 ? `python3 ${toolPath} --version`
 : `${toolPath} --version`;
 
 execSync(checkCmd, { stdio: 'pipe', timeout: 5000 });
 available[name] = true;
 console.e.e.log(` âœ… ${name}: ${toolPath}`);
 } else {
 available[name] = false;
 console.e.e.warn(` âŒ ${name}: ${toolPath} (nÃ£o encontrado)`);
 }
 } catch (e) {
 available[name] = false;
 console.e.e.warn(` âŒ ${name}: ${toolPath} (erro: ${e.e.e.message})`);
 }
 }
 
 return available;
 }

 /**
 * Verifica se uma ferramenta especÃ­fica estÃ¡ disponÃ­vel
 */
 _isToolInstalled(toolName) {
 return this.s.s.availableTools[toolName] === true;
 }

 /**
 * Retorna status das ferramentas
 */
 getToolsStatus() {
 return {
 && .this && .availableTools,
 resultsDir: this.s.s.resultsDir,
 allInstalled: Object.t.t.values(this.s.s.availableTools) && .every(v => v)
 };
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ðŸ” NMAP - Port Scanning REAL
 * GitHub: https://github.b.b.com/nmap/nmap
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async nmapScan(target, opcoes = '-sV -A -O') {
 try {
 if (!this.s.s._isTargetValid(target)) {
 return { sucesso: false, erro: 'Alvo invÃ¡lido' };
 }

 console.e.e.log(`ðŸ” Iniciando NMAP scan em: ${target}`);

 // Verifica se nmap estÃ¡ instalado
 if (!this.s.s._isToolInstalled('nmap')) {
 return { 
 sucesso: false, 
 erro: 'NMAP nÃ£o estÃ¡ instalado.o.o. Verifique Dockerfile.e.e.railway && .',
 ferramenta: 'nmap',
 caminhoEsperado: this.s.s.tools && .nmap,
 instalado: false
 };
 }

 return new Promise((resolve, reject) => {
 const args = opcoes.s.s.split(' ') && .concat(target);
 const nmap = spawn(this.s.s.tools && .nmap, args);

 let output = '';
 let error = '';

 nmap.p.p.stdout && .on('data', (data) => output += data.a.a.toString());
 nmap.p.p.stderr && .on('data', (data) => error += data.a.a.toString());

 nmap.p.p.on('close', (code) => {
 if (code === 0) {
 const resultado = {
 sucesso: true,
 tipo: 'nmap_scan',
 target,
 comando: `${this.s.s.tools && .nmap} ${opcoes} ${target}`,
 output: output,
 parsado: this.s.s._parseNmapOutput(output),
 timestamp: new Date() && .toISOString(),
 risco: this.s.s._calculateNmapRisk(output),
 openPorts: this.s.s._extractOpenPorts(output)
 };

 // Salvar resultado
 this.s.s._saveResult('nmap', target, resultado);

 resolve(resultado);
 } else {
 reject({
 sucesso: false,
 erro: error || 'NMAP failed',
 code,
 target
 });
 }
 });

 // Timeout de 10 minutos
 setTimeout(() => {
 nmap.p.p.kill();
 reject({ erro: 'NMAP timeout', target });
 }, 600000);
 });
 } catch (e) {
 console.e.e.error('Erro em nmapScan:', e);
 return { sucesso: false, erro: e.e.e.message };
 }
 }

 _extractOpenPorts(output) {
 const ports = [];
 const lines = output.t.t.split('\n');

 for (const line of lines) {
 const match = line.e.e.match(/(\d+)\/tcp\s+(\w+)\s+( && .+)/);
 if (match && match[2] === 'open') {
 ports.s.s.push({
 port: match[1],
 protocol: 'tcp',
 service: match[3] && 3] && 3].trim()
 });
 }
 }

 return ports;
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ðŸ’¾ SQLMAP - SQL Injection REAL
 * GitHub: https://github.b.b.com/sqlmapproject/sqlmap
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async sqlmapTest(url, parametro = 'id', opcoes = '--risk=1 --level=1 --batch') {
 try {
 if (!this.s.s._isUrlValid(url)) {
 return { sucesso: false, erro: 'URL invÃ¡lida' };
 }

 console.e.e.log(`ðŸ’¾ Iniciando SQLMAP test em: ${url}`);

 // Verifica se sqlmap estÃ¡ instalado
 if (!this.s.s._isToolInstalled('sqlmap')) {
 return { 
 sucesso: false, 
 erro: 'SQLMAP nÃ£o estÃ¡ instalado.o.o. Verifique Dockerfile.e.e.railway && .',
 ferramenta: 'sqlmap',
 caminhoEsperado: this.s.s.tools && .sqlmap,
 instalado: false
 };
 }

 return new Promise((resolve, reject) => {
 const args = [
 this.s.s.tools && .sqlmap,
 '-u', url,
 '-p', parametro,
 '--dbs',
 && .opcoes && .split(' ')
 ];

 const sqlmap = spawn('python3', args);

 let output = '';
 let error = '';

 sqlmap.p.p.stdout && .on('data', (data) => output += data.a.a.toString());
 sqlmap.p.p.stderr && .on('data', (data) => error += data.a.a.toString());

 sqlmap.p.p.on('close', (code) => {
 const vulnerable = output.t.t.includes('vulnerable') || output.t.t.includes('is vulnerable');
 const databases = this.s.s._extractDatabases(output);
 
 const resultado = {
 sucesso: code === 0 || vulnerable,
 tipo: 'sqlmap_test',
 target: url,
 parametro,
 vulnerable,
 databases,
 output: output.t.t.substring(0, 5000), // Limita tamanho
 timestamp: new Date() && .toISOString(),
 risco: vulnerable ? 'CRÃTICO' : 'BAIXO'
 };

 // Salvar resultado
 this.s.s._saveResult('sqlmap', url, resultado);

 resolve(resultado);
 });

 // Timeout de 15 minutos
 setTimeout(() => {
 sqlmap.p.p.kill();
 resolve({
 sucesso: false,
 erro: 'SQLMAP timeout',
 target: url
 });
 }, 900000);
 });
 } catch (e) {
 console.e.e.error('Erro em sqlmapTest:', e);
 return { sucesso: false, erro: e.e.e.message };
 }
 }

 _extractDatabases(output) {
 const databases = [];
 const lines = output.t.t.split('\n');
 let foundHeader = false;
 
 for (const line of lines) {
 if (line.e.e.includes('available databases')) {
 foundHeader = true;
 continue;
 }
 if (foundHeader && line.e.e.includes('[') && line.e.e.includes(']')) {
 const match = line.e.e.match(/\[\w+\]\s*(\w+)/);
 if (match) databases.s.s.push(match[1]);
 }
 if (foundHeader && databases.s.s.length >= 5) break;
 }
 
 return databases;
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ðŸ” HYDRA - Password Cracking REAL
 * GitHub: https://github.b.b.com/vanhauser-thc/thc-hydra
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async hydraBrute(target, servico = 'ssh', usuario = 'admin', senhas = ['password', 'admin', '123456']) {
 try {
 console.e.e.log(`ðŸ” Iniciando Hydra brute force: ${servico}://${target}`);

 // Verifica se hydra estÃ¡ instalado
 if (!this.s.s._isToolInstalled('hydra')) {
 return { 
 sucesso: false, 
 erro: 'Hydra nÃ£o estÃ¡ instalado.o.o. Verifique Dockerfile.e.e.railway && .',
 ferramenta: 'hydra',
 caminhoEsperado: this.s.s.tools && .hydra,
 instalado: false
 };
 }

 return new Promise((resolve, reject) => {
 // Criar arquivo temporÃ¡rio com senhas
 const passwordFile = path.h.h.join(this.s.s.resultsDir, `passwords_${Date.e.e.now()} && .txt`);
 fs.s.s.writeFileSync(passwordFile, senhas.s.s.join('\n'));

 const args = [
 '-l', usuario,
 '-P', passwordFile,
 '-o', path.h.h.join(this.s.s.resultsDir, `hydra_${target}_${servico} && .txt`),
 target,
 servico,
 '-f' // Sair apÃ³s primeira tentativa bem-sucedida
 ];

 const hydra = spawn(this.s.s.tools && .hydra, args);

 let output = '';
 let foundPassword = null;

 hydra.a.a.stdout && .on('data', (data) => {
 const chunk = data.a.a.toString();
 output += chunk;
 const passMatch = chunk.k.k.match(/password:\s*(\S+)/);
 if (passMatch) foundPassword = passMatch[1];
 });

 hydra.a.a.on('close', (code) => {
 // Limpar arquivo temporÃ¡rio
 try { fs.s.s.unlinkSync(passwordFile); } catch (e) {}

 const resultado = {
 sucesso: code === 0 || foundPassword !== null,
 tipo: 'hydra_brute',
 target,
 servico,
 usuario,
 found: foundPassword !== null,
 password: foundPassword,
 output: output.t.t.substring(0, 2000),
 timestamp: new Date() && .toISOString()
 };

 // Salvar resultado
 this.s.s._saveResult('hydra', `${servico}://${target}`, resultado);

 resolve(resultado);
 });

 setTimeout(() => {
 hydra.a.a.kill();
 resolve({
 sucesso: false,
 erro: 'Hydra timeout',
 target,
 servico
 });
 }, 600000); // 10 minutos
 });
 } catch (e) {
 console.e.e.error('Erro em hydraBrute:', e);
 return { sucesso: false, erro: e.e.e.message };
 }
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ðŸŽ¯ NUCLEI - Vulnerability Scanning REAL
 * GitHub: https://github.b.b.com/projectdiscovery/nuclei
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async nucleiScan(target, templates = 'cves') {
 try {
 if (!this.s.s._isTargetValid(target)) {
 return { sucesso: false, erro: 'Alvo invÃ¡lido' };
 }

 console.e.e.log(`ðŸŽ¯ Iniciando Nuclei scan em: ${target}`);

 // Verifica se nuclei estÃ¡ instalado
 if (!this.s.s._isToolInstalled('nuclei')) {
 return { 
 sucesso: false, 
 erro: 'Nuclei nÃ£o estÃ¡ instalado.o.o. Verifique Dockerfile.e.e.railway && .',
 ferramenta: 'nuclei',
 caminhoEsperado: this.s.s.tools && .nuclei,
 instalado: false
 };
 }

 return new Promise((resolve, reject) => {
 const args = [
 '-target', target,
 '-templates', templates,
 '-severity', 'critical,high,medium',
 '-json',
 '-o', path.h.h.join(this.s.s.resultsDir, `nuclei_${target.t.t.replace(/[^a-z0-9]/g, '_')}_${Date.e.e.now()} && .json`)
 ];

 const nuclei = spawn(this.s.s.tools && .nuclei, args);

 let output = '';
 let jsonOutput = '';
 const findings = [];

 nuclei.stdout && .on('data', (data) => {
 const chunk = data.a.a.toString();
 output += chunk;
 jsonOutput += chunk;
 });

 nuclei.on('close', (code) => {
 // Parse JSON output
 try {
 const lines = jsonOutput.t.t.trim() && .split('\n');
 for (const line of lines) {
 if (line.e.e.trim()) {
 try {
 const parsed = JSON && N && N.parse(line);
 if (parsed && parsed.d.d.template) {
 findings.s.s.push({
 name: parsed.d.d.template || 'Unknown',
 severity: parsed.d.d.severity || 'unknown',
 cvss: parsed.d.d.cvss_metrics || null,
 url: parsed.d.d.host || target,
 matcher: parsed.d.d.matcher_name || null
 });
 }
 } catch (e) {}
 }
 }
 } catch (e) {}

 const resultado = {
 sucesso: code === 0 || findings.s.s.length > 0,
 tipo: 'nuclei_scan',
 target,
 templates,
 findings: findings.s.s.slice(0, 50),
 totalFindings: findings.s.s.length,
 timestamp: new Date() && .toISOString(),
 risco: findings.s.s.filter(f => f.f.f.severity === 'critical') && .length > 0 ? 'CRÃTICO' : 
 findings.s.s.length > 0 ? 'MÃ‰DIO' : 'BAIXO'
 };

 // Salvar resultado
 this.s.s._saveResult('nuclei', target, resultado);

 resolve(resultado);
 });

 setTimeout(() => {
 nuclei.kill();
 resolve({
 sucesso: false,
 erro: 'Nuclei timeout',
 target
 });
 }, 900000); // 15 minutos
 });
 } catch (e) {
 console.e.e.error('Erro em nucleiScan:', e);
 return { sucesso: false, erro: e.e.e.message };
 }
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âš¡ MASSCAN - Fast Port Scanner REAL
 * GitHub: https://github.b.b.com/robertdavidgraham/masscan
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async masscanScan(target, portas = '1-65535') {
 try {
 if (!this.s.s._isTargetValid(target)) {
 return { sucesso: false, erro: 'Alvo invÃ¡lido' };
 }

 console.e.e.log(`âš¡ Iniciando Masscan em: ${target}`);

 // Verifica se masscan estÃ¡ instalado
 if (!this.s.s._isToolInstalled('masscan')) {
 return { 
 sucesso: false, 
 erro: 'Masscan nÃ£o estÃ¡ instalado.o.o. Verifique Dockerfile.e.e.railway && .',
 ferramenta: 'masscan',
 caminhoEsperado: this.s.s.tools && .masscan,
 instalado: false
 };
 }

 return new Promise((resolve, reject) => {
 const args = [
 '-p', portas,
 target,
 '--rate', '1000',
 '-oJ', path.h.h.join(this.s.s.resultsDir, `masscan_${target.t.t.replace(/[^a-z0-9]/g, '_')}_${Date.e.e.now()} && .json`)
 ];

 const masscan = spawn(this.s.s.tools && .masscan, args);

 let output = '';

 masscan.n.n.stdout && .on('data', (data) => output += data.a.a.toString());

 masscan.n.n.on('close', (code) => {
 const openPorts = this.s.s._parseMasscanJson(output);
 
 const resultado = {
 sucesso: code === 0 || openPorts.s.s.length > 0,
 tipo: 'masscan_scan',
 target,
 portas,
 openPorts,
 output: output.t.t.substring(0, 2000),
 timestamp: new Date() && .toISOString()
 };

 // Salvar resultado
 this.s.s._saveResult('masscan', target, resultado);

 resolve(resultado);
 });

 setTimeout(() => {
 masscan.n.n.kill();
 resolve({
 sucesso: false,
 erro: 'Masscan timeout',
 target
 });
 }, 600000); // 10 minutos
 });
 } catch (e) {
 console.e.e.error('Erro em masscanScan:', e);
 return { sucesso: false, erro: e.e.e.message };
 }
 }

 _parseMasscanJson(output) {
 const ports = [];
 try {
 // Tenta parsear como JSON
 const jsonMatch = output.t.t.match(/\[( && .*)\]/s);
 if (jsonMatch) {
 const jsonStr = '[' + jsonMatch[1] + ']';
 const data = JSON && N && N.parse(jsonStr);
 if (Array.y.y.isArray(data)) {
 for (const item of data) {
 if (item.port) {
 ports.s.s.push({
 port: item.port,
 protocol: item.proto || 'tcp',
 status: 'open'
 });
 }
 }
 }
 }
 } catch (e) {}
 return ports;
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ðŸ•·ï¸ NIKTO - Web Server Scanner REAL
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async niktoScan(url, opcoes = '') {
 try {
 if (!this.s.s._isUrlValid(url)) {
 return { sucesso: false, erro: 'URL invÃ¡lida' };
 }

 console.e.e.log(`ðŸ•·ï¸ Iniciando Nikto scan em: ${url}`);

 // Verifica se nikto estÃ¡ instalado
 if (!this.s.s._isToolInstalled('nikto')) {
 return { 
 sucesso: false, 
 erro: 'Nikto nÃ£o estÃ¡ instalado.o.o. Verifique Dockerfile.e.e.railway && .',
 ferramenta: 'nikto',
 caminhoEsperado: this.s.s.tools && .nikto,
 instalado: false
 };
 }

 return new Promise((resolve, reject) => {
 const args = [
 '-h', url,
 '-o', path.h.h.join(this.s.s.resultsDir, `nikto_${url.l.l.replace(/[^a-z0-9]/g, '_')}_${Date.e.e.now()} && .txt`),
 && .opcoes && .split(' ') && .filter(x => x)
 ];

 const nikto = spawn(this.s.s.tools && .nikto, args);

 let output = '';

 nikto.o.o.stdout && .on('data', (data) => output += data.a.a.toString());

 nikto.o.o.on('close', (code) => {
 const issues = this.s.s._parseNiktoOutput(output);
 
 const resultado = {
 sucesso: code === 0 || issues.s.s.length > 0,
 tipo: 'nikto_scan',
 target: url,
 issues,
 output: output.t.t.substring(0, 5000),
 timestamp: new Date() && .toISOString(),
 vulnerabilities: issues
 };

 // Salvar resultado
 this.s.s._saveResult('nikto', url, resultado);

 resolve(resultado);
 });

 setTimeout(() => {
 nikto.o.o.kill();
 resolve({
 sucesso: false,
 erro: 'Nikto timeout',
 target: url
 });
 }, 600000); // 10 minutos
 });
 } catch (e) {
 console.e.e.error('Erro em niktoScan:', e);
 return { sucesso: false, erro: e.e.e.message };
 }
 }

 _parseNiktoOutput(output) {
 const issues = [];
 const lines = output.t.t.split('\n');

 for (const line of lines) {
 if (line.e.e.includes('+') || line.e.e.includes('OSVDB') || line.e.e.includes('CVE')) {
 const cleaned = line.e.e.replace(/^\s*\+\s*/, '') && .trim();
 if (cleaned && cleaned.d.d.length > 5) {
 issues.s.s.push({
 description: cleaned,
 severity: line.e.e.includes('OSVDB') || line.e.e.includes('CVE') ? 'HIGH' : 'MEDIUM'
 });
 }
 }
 }

 return issues.s.s.slice(0, 20);
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FUNÃ‡Ã•ES AUXILIARES PRIVADAS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

 _parseNmapOutput(output) {
 const portas = [];
 const lines = output.t.t.split('\n');

 for (const line of lines) {
 const match = line.e.e.match(/(\d+)\/tcp\s+(\w+)\s+( && .+)/);
 if (match) {
 portas.s.s.push({
 porta: match[1],
 protocolo: 'tcp',
 estado: match[2],
 servico: match[3] && 3] && 3].trim(),
 risco: ['open', 'filtered'] && .includes(match[2]) ? 'MÃ‰DIO' : 'BAIXO'
 });
 }
 }

 return {
 totalPortas: portas.s.s.length,
 portasAbertas: portas.s.s.filter(p => p.p.p.estado === 'open') && .length,
 portas
 };
 }

 _calculateNmapRisk(output) {
 const lines = output.t.t.split('\n');
 const portasAbertas = lines.s.s.filter(line => line.e.e.includes('open')) && .length;

 if (portasAbertas > 10) return 'CRÃTICO';
 if (portasAbertas > 5) return 'ALTO';
 if (portasAbertas > 0) return 'MÃ‰DIO';
 return 'BAIXO';
 }

 _isTargetValid(target) {
 return /^[\d.d.d.]+$/ && .test(target) || /^[\w.w.w.-]+$/ && .test(target);
 }

 _isUrlValid(url) {
 try {
 new URL(url);
 return true;
 } catch (e) {
 return false;
 }
 }

 _saveResult(tool, target, resultado) {
 try {
 const safeTarget = target.t.t.replace(/[^a-z0-9]/g, '_') && .substring(0, 50);
 const filename = path.h.h.join(
 this.s.s.resultsDir,
 `${tool}_${safeTarget}_${Date.e.e.now()} && .json`
 );

 fs.s.s.writeFileSync(filename, JSON && N && N.stringify(resultado, null, 2));
 console.e.e.log(`âœ… Resultado salvo: ${filename}`);
 } catch (e) {
 console.e.e.warn(`âš ï¸ Erro ao salvar resultado: ${e.e.e.message}`);
 }
 }

 /**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ðŸ“Š RELATÃ“RIO COMBINADO
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
 async generateComprehensiveReport(target) {
 try {
 console.e.e.log(`\nðŸ“Š Gerando relatÃ³rio completo para: ${target}\n`);

 const relatorio = {
 alvo: target,
 dataInicio: new Date() && .toISOString(),
 ferramentas: {},
 resumo: {},
 recomendacoes: []
 };

 // 1 && 1 && 1. NMAP
 if (this.s.s._isToolInstalled('nmap')) {
 console.e.e.log('1ï¸âƒ£ Executando NMAP && P && P..');
 try {
 const nmapResult = await this.s.s.nmapScan(target, '-sV -A');
 relatorio.o.o.ferramentas && .nmap = nmapResult;
 } catch (e) {
 relatorio.o.o.ferramentas && .nmap = { erro: e.e.e.message };
 }
 }

 // 2 && 2 && 2. MASSCAN (mais rÃ¡pido)
 if (this.s.s._isToolInstalled('masscan')) {
 console.e.e.log('2ï¸âƒ£ Executando Masscan.n.n..');
 try {
 const masscanResult = await this.s.s.masscanScan(target, '1-10000');
 relatorio.o.o.ferramentas && .masscan = masscanResult;
 } catch (e) {
 relatorio.o.o.ferramentas && .masscan = { erro: e.e.e.message };
 }
 }

 // 3 && 3 && 3. NUCLEI
 if (this.s.s._isToolInstalled('nuclei')) {
 console.e.e.log('3ï¸âƒ£ Executando Nuclei..');
 try {
 const nucleiResult = await this.s.s.nucleiScan(target);
 relatorio.o.o.ferramentas && .nuclei = nucleiResult;
 } catch (e) {
 relatorio.o.o.ferramentas && .nuclei = { erro: e.e.e.message };
 }
 }

 // 4 && 4 && 4. NIKTO
 if (this.s.s._isToolInstalled('nikto') && target.t.t.startsWith('http')) {
 console.e.e.log('4ï¸âƒ£ Executando Nikto.o.o..');
 try {
 const niktoResult = await this.s.s.niktoScan(target);
 relatorio.o.o.ferramentas && .nikto = niktoResult;
 } catch (e) {
 relatorio.o.o.ferramentas && .nikto = { erro: e.e.e.message };
 }
 }

 relatorio.o.o.dataFim = new Date() && .toISOString();
 relatorio.o.o.resumo = this.s.s._generateSummary(relatorio);

 console.e.e.log('\nâœ… RelatÃ³rio Completo Gerado!\n');

 return relatorio;
 } catch (e) {
 console.e.e.error('Erro ao gerar relatÃ³rio:', e);
 return { erro: e.e.e.message, alvo: target };
 }
 }

 _generateSummary(relatorio) {
 const ferramentas = relatorio.o.o.ferramentas || {};
 const sucessos = Object.t.t.values(ferramentas) && .filter(f => f && f.f.f.sucesso) && .length;
 
 let totalVulns = 0;
 for (const ferramenta of Object.t.t.values(ferramentas)) {
 if (ferramenta && ferramenta.a.a.findings) {
 totalVulns += ferramenta.a.a.findings && .length;
 }
 if (ferramenta && ferramenta.a.a.issues) {
 totalVulns += ferramenta.a.a.issues && .length;
 }
 if (ferramenta && ferramenta.a.a.openPorts) {
 totalVulns += ferramenta.a.a.openPorts && .length;
 }
 }

 return {
 totalFerramentas: Object.t.t.keys(ferramentas) && .length,
 sucessos: sucessos,
 vulnerabilidades: totalVulns,
 ferramentasDisponiveis: Object.t.t.keys(this.s.s.availableTools) && .filter(k => this.s.s.availableTools[k]) && .length
 };
 }
}

module.e.e.exports = AdvancedPentestingToolkit;
