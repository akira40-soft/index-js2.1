/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ADVANCED PENTESTING TOOLKIT - REAL TOOLS v3
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ… NMAP - Port scanning real (github.com/nmap/nmap)
 * âœ… SQLMAP - SQL injection real (github.com/sqlmapproject/sqlmap)
 * âœ… Hydra - Password cracking (github.com/vanhauser-thc/thc-hydra)
 * âœ… Nuclei - Vulnerability scanning (github.com/projectdiscovery/nuclei)
 * âœ… Masscan - Fast port scanner (github.com/robertdavidgraham/masscan)
 * âœ… Nikto - Web server scanner (github.com/sullo/nikto)
 * âœ… Commix - Command injection (github.com/commixproject/commix)
 * âœ… SearchSploit - Exploit database (github.com/offensive-security/exploitdb)
 * 
 * NOTA: SEToolkit e MetasploitåŸå§‹ foram substituÃ­dos por alternativas
 * que funcionam no Alpine Linux: Commix e SearchSploit
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { spawn, execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

class AdvancedPentestingToolkit {
    private config: any;
    private tools: Record<string, string>;
    private resultsDir: string;
    private availableTools: Record<string, boolean> = {};

    constructor(config: any) {
        this.config = config;

        // Caminhos das ferramentas - correspondem ao Dockerfile.railway
        // SEToolkit -> SubstituÃ­do por SocialFish/BlackEye (Python)
        // Metasploit -> SubstituÃ­do por Commix + SearchSploit
        this.tools = {
            nmap: '/usr/bin/nmap',
            sqlmap: '/opt/sqlmap/sqlmap.py',
            hydra: '/usr/bin/hydra',
            nuclei: '/usr/local/bin/nuclei',
            masscan: '/usr/local/bin/masscan',
            nikto: '/usr/bin/nikto',
            commix: '/usr/local/bin/commix',
            searchsploit: '/usr/bin/searchsploit',
            socialfish: '/usr/local/bin/socialfish',
            blackeye: '/opt/blackeye/blackeye.py'
        };

        // DiretÃ³rio de resultados
        this.resultsDir = config.resultsDir || '/tmp/pentest_results';
        if (!fs.existsSync(this.resultsDir)) {
            fs.mkdirSync(this.resultsDir, { recursive: true });
        }

        this._checkAvailableTools();
    }

    _checkAvailableTools() {
        const available: { [key: string]: boolean } = {};
        console.log('ğŸ” Verificando ferramentas de seguranÃ§a...');

        for (const [name, toolPath] of Object.entries(this.tools)) {
            try {
                if (fs.existsSync(toolPath)) {
                    let checkCmd;
                    switch (name) {
                        case 'sqlmap':
                            checkCmd = `python3 ${toolPath} --version`;
                            break;
                        case 'hydra':
                            checkCmd = `${toolPath} -h`;
                            break;
                        case 'nikto':
                        case 'nuclei':
                            checkCmd = `${toolPath} -version`;
                            break;
                        case 'commix':
                            checkCmd = `${toolPath} --version`;
                            break;
                        case 'searchsploit':
                            checkCmd = `${toolPath} --help 2>&1 | head -5`;
                            break;
                        case 'socialfish':
                            checkCmd = `python3 ${toolPath} --help 2>&1 | head -3`;
                            break;
                        case 'blackeye':
                            checkCmd = `python3 ${toolPath} --help 2>&1 | head -3`;
                            break;
                        default:
                            checkCmd = `${toolPath} --version`;
                    }

                    execSync(checkCmd, { stdio: 'pipe', timeout: 5000 });
                    available[name] = true;
                    console.log(` âœ… ${name}: ${toolPath}`);
                } else {
                    available[name] = false;
                    console.warn(` âŒ ${name}: ${toolPath} (nÃ£o encontrado)`);
                }
            } catch (e: any) {
                if (fs.existsSync(toolPath)) {
                    available[name] = true;
                    console.log(` âœ… ${name}: ${toolPath} (verificado com aviso)`);
                } else {
                    available[name] = false;
                    console.warn(` âŒ ${name}: ${toolPath} (erro: ${e.message})`);
                }
            }
        }

        this.availableTools = available;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FERRAMENTAS ORIGINAIS (mantidas)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async nmapScan(target: string, opcoes: string = '-sV -T4'): Promise<any> {
        if (!this.availableTools.nmap) return { error: 'Nmap nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = opcoes.split(' ').concat(target);
            const nmap = spawn(this.tools.nmap, args);

            let output = '';
            let error = '';

            nmap.stdout.on('data', (data) => output += data.toString());
            nmap.stderr.on('data', (data) => error += data.toString());

            nmap.on('close', (code) => {
                if (code === 0) {
                    const result = { tool: 'nmap', target, output, timestamp: new Date() };
                    this._saveResult('nmap', target, result);
                    resolve(result);
                } else {
                    reject({ tool: 'nmap', error: error || 'Erro desconhecido', code });
                }
            });
        });
    }

    async sqlmapTest(url: string, parametro: string): Promise<any> {
        if (!this.availableTools.sqlmap) return { error: 'SQLMap nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                this.tools.sqlmap,
                '-u', url,
                '-p', parametro,
                '--batch',
                '--dbs',
                '--level=1',
                '--risk=1'
            ];

            const sqlmap = spawn('python3', args);
            let output = '';
            let error = '';

            sqlmap.stdout.on('data', (data) => output += data.toString());
            sqlmap.stderr.on('data', (data) => error += data.toString());

            sqlmap.on('close', (code) => {
                const result = { tool: 'sqlmap', target: url, output, timestamp: new Date() };
                this._saveResult('sqlmap', url, result);
                resolve(result);
            });
        });
    }

    async hydraBrute(target: string, servico: string, usuario: string, wordlist: string[] | null = null): Promise<any> {
        if (!this.availableTools.hydra) return { error: 'Hydra nÃ£o instalado' };

        const senhas = wordlist || ['123456', 'password', 'admin', 'root', '12345'];
        const passwordFile = path.join(this.resultsDir, `passwords_${Date.now()}.txt`);
        fs.writeFileSync(passwordFile, senhas.join('\n'));

        return new Promise((resolve, reject) => {
            const args = [
                '-l', usuario,
                '-P', passwordFile,
                '-o', path.join(this.resultsDir, `hydra_${target}_${servico}.txt`),
                target,
                servico,
                '-f'
            ];

            const hydra = spawn(this.tools.hydra, args);
            let output = '';

            hydra.stdout.on('data', (data) => output += data.toString());

            hydra.on('close', (code) => {
                fs.unlinkSync(passwordFile);
                const result = { tool: 'hydra', target, service: servico, output, timestamp: new Date() };
                this._saveResult('hydra', target, result);
                resolve(result);
            });
        });
    }

    async nucleiScan(target: string, templates: string = 'cves'): Promise<any> {
        if (!this.availableTools.nuclei) return { error: 'Nuclei nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                '-target', target,
                '-templates', templates,
                '-severity', 'critical,high,medium',
                '-json',
                '-o', path.join(this.resultsDir, `nuclei_${target.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.json`)
            ];

            const nuclei = spawn(this.tools.nuclei, args);
            let output = '';

            nuclei.stdout.on('data', (data) => output += data.toString());

            nuclei.on('close', (code) => {
                try {
                    const resultFile = args[args.indexOf('-o') + 1];
                    let results = [];
                    if (fs.existsSync(resultFile)) {
                        const content = fs.readFileSync(resultFile, 'utf8');
                        results = content.split('\n').filter((x: string) => x).map((line: string) => JSON.parse(line));
                    }

                    const report = { tool: 'nuclei', target, vulnerabilities: results, timestamp: new Date() };
                    this._saveResult('nuclei', target, report);
                    resolve(report);
                } catch (e: any) {
                    reject(e);
                }
            });
        });
    }

    async masscanScan(target: string, portas: string = '80,443,8080,22'): Promise<any> {
        if (!this.availableTools.masscan) return { error: 'Masscan nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                '-p', portas,
                target,
                '--rate', '1000',
                '-oJ', path.join(this.resultsDir, `masscan_${target.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.json`)
            ];

            const masscan = spawn(this.tools.masscan, args);
            let output = '';

            masscan.stdout.on('data', (data) => output += data.toString());

            masscan.on('close', (code) => {
                try {
                    const resultFile = args[args.indexOf('-oJ') + 1];
                    const content = fs.existsSync(resultFile) ? JSON.parse(fs.readFileSync(resultFile, 'utf8')) : [];
                    const result = { tool: 'masscan', target, ports: content, timestamp: new Date() };
                    this._saveResult('masscan', target, result);
                    resolve(result);
                } catch (e: any) {
                    reject(e);
                }
            });
        });
    }

    async niktoScan(url: string, opcoes: string = ''): Promise<any> {
        if (!this.availableTools.nikto) return { error: 'Nikto nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                '-h', url,
                '-o', path.join(this.resultsDir, `nikto_${url.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.txt`),
                ...opcoes.split(' ').filter(x => x)
            ];

            const nikto = spawn(this.tools.nikto, args);
            let output = '';

            nikto.stdout.on('data', (data) => output += data.toString());

            nikto.on('close', (code) => {
                const result = { tool: 'nikto', target: url, output, timestamp: new Date() };
                this._saveResult('nikto', url, result);
                resolve(result);
            });
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NOVAS FERRAMENTAS (Substitutos do Metasploit)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * COMMIX - Command Injection Scanner
     * Substituto do Metasploit para exploitation de Command Injection
     * 
     * O Commix automatiza a detecÃ§Ã£o e exploraÃ§Ã£o de vulnerabilidades
     * de Command Injection em aplicaÃ§Ãµes web. Similar a algumas funÃ§Ãµes
     * do Metasploit mas especializado neste tipo de ataque.
     */
    async commixScan(url: string, parametro: string = 'id'): Promise<any> {
        if (!this.availableTools.commix) {
            return { 
                tool: 'commix',
                error: 'Commix nÃ£o instalado',
                install: 'pip install commix ou apt-get install commix'
            };
        }

        return new Promise((resolve, reject) => {
            const args = [
                this.tools.commix,
                '-u', `${url}?${parametro}=test`,
                '--batch',
                '--level=1',
                '--risk=1'
            ];

            const commix = spawn('python3', args);
            let output = '';
            let error = '';

            commix.stdout.on('data', (data) => output += data.toString());
            commix.stderr.on('data', (data) => error += data.toString());

            commix.on('close', (code) => {
                const result = { 
                    tool: 'commix', 
                    target: url, 
                    parameter: parametro,
                    output, 
                    timestamp: new Date() 
                };
                this._saveResult('commix', url, result);
                resolve(result);
            });
        });
    }

    /**
     * SEARCHSPLOIT - Exploit Database
     * Substituto parcial do Metasploit para busca de exploits
     * 
     * O SearchSploit fornece acesso ao banco de dados de exploits
     * do Exploit-DB, permitindo buscar vulnerabilidades conhecidas.
     */
    async searchExploit(termo: string): Promise<any> {
        if (!this.availableTools.searchsploit) {
            return { 
                tool: 'searchsploit',
                error: 'SearchSploit nÃ£o instalado',
                install: 'apt-get install exploitdb'
            };
        }

        return new Promise((resolve, reject) => {
            const args = [
                this.tools.searchsploit,
                termo,
                '--json'
            ];

            const search = spawn('searchsploit', args);
            let output = '';
            let error = '';

            search.stdout.on('data', (data) => output += data.toString());
            search.stderr.on('data', (data) => error += data.toString());

            search.on('close', (code) => {
                const result = { 
                    tool: 'searchsploit', 
                    search: termo,
                    output, 
                    timestamp: new Date() 
                };
                this._saveResult('searchsploit', termo, result);
                resolve(result);
            });
        });
    }

    /**
     * SEARCHSPLOIT - Buscar por exploit especÃ­fico
     */
    async searchExploitById(id: string): Promise<any> {
        if (!this.availableTools.searchsploit) {
            return { error: 'SearchSploit nÃ£o instalado' };
        }

        return new Promise((resolve) => {
            try {
                const args = [this.tools.searchsploit, '-p', id];
                const output = execSync(args.join(' '), { encoding: 'utf8', timeout: 10000 });
                
                const result = { 
                    tool: 'searchsploit', 
                    exploitId: id,
                    output, 
                    timestamp: new Date() 
                };
                this._saveResult('searchsploit_id', id, result);
                resolve(result);
            } catch (e: any) {
                resolve({ error: e.message });
            }
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FERRAMENTAS DE PHISHING (Substituto do SEToolkit)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * SOCIALFISH - Social Engineering Tool
     * Substituto do SEToolkit para phishing awareness
     * 
     * O SocialFish Ã© uma ferramenta de phishing que cloneia pÃ¡ginas
     * de login populares para teste de conscientizaÃ§Ã£o de seguranÃ§a.
     * Funciona em Python e Ã© mais leve que o SET.
     */
    async socialFishHelp(): Promise<any> {
        if (!this.availableTools.socialfish) {
            return { 
                tool: 'socialfish',
                info: 'SocialFish nÃ£o instalado',
                install: 'git clone https://github.com/UndeadSec/SocialFish.git && cd SocialFish && pip install -r requirements.txt',
                note: 'Esta ferramenta requer Python 3.x e acesso root para funcionar corretamente'
            };
        }

        return new Promise((resolve) => {
            try {
                const output = execSync(`python3 ${this.tools.socialfish} --help 2>&1`, { 
                    encoding: 'utf8', 
                    timeout: 10000 
                });
                
                resolve({ 
                    tool: 'socialfish', 
                    output,
                    usage: 'python3 socialfish.py <template> <Ngrok-token>'
                });
            } catch (e: any) {
                resolve({ error: e.message });
            }
        });
    }

    /**
     * BLACKEYE - Phishing Tool
     * Alternativa ao SocialFish com mais templates
     */
    async blackEyeHelp(): Promise<any> {
        if (!this.availableTools.blackeye) {
            return { 
                tool: 'blackeye',
                info: 'BlackEye nÃ£o instalado',
                install: 'git clone https://github.com/thelinuxchoice/blackeye.git && cd blackeye && bash install.sh',
                note: 'Ferramenta de phishing com mÃºltiplos templates'
            };
        }

        return new Promise((resolve) => {
            try {
                const output = execSync(`python3 ${this.tools.blackeye} 2>&1 | head -30`, { 
                    encoding: 'utf8', 
                    timeout: 10000 
                });
                
                resolve({ 
                    tool: 'blackeye', 
                    output,
                    usage: 'python3 blackeye.py'
                });
            } catch (e: any) {
                resolve({ error: e.message });
            }
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // METODOS LEGACY (Mantidos para compatibilidade)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async setoolkitHelp(target: string): Promise<any> {
        // SEToolkit substituÃ­do por SocialFish/BlackEye
        return { 
            tool: 'setoolkit',
            status: 'REMOVIDO',
            reason: 'Problemas de build no Alpine Linux',
            alternatives: [
                { name: 'SocialFish', cmd: '#socialfish' },
                { name: 'BlackEye', cmd: '#blackeye' }
            ],
            install: 'git clone https://github.com/UndeadSec/SocialFish.git'
        };
    }

    async metasploitCheck(target: string): Promise<any> {
        // Metasploit substituÃ­do por Commix + SearchSploit
        return { 
            tool: 'metasploit',
            status: 'REMOVIDO',
            reason: 'Problemas de build no Alpine Linux',
            alternatives: [
                { name: 'Commix', desc: 'Command Injection Scanner', cmd: '#commix' },
                { name: 'SearchSploit', desc: 'Exploit Database', cmd: '#searchsploit' },
                { name: 'Nmap', desc: 'Port Scanner', cmd: '#nmap' },
                { name: 'SQLMap', desc: 'SQL Injection', cmd: '#sqlmap' },
                { name: 'Nuclei', desc: 'Vulnerability Scanner', cmd: '#nuclei' }
            ],
            install: 'Para usar Metasploit, execute via Docker: docker run -it metasploitframework/metasploit-framework'
        };
    }

    private _saveResult(tool: string, target: string, result: any): void {
        const safeTarget = target.replace(/[^a-z0-9]/g, '_').substring(0, 50);
        const filename = path.join(
            this.resultsDir,
            `${tool}_${safeTarget}_${Date.now()}.json`
        );

        fs.writeFileSync(filename, JSON.stringify(result, null, 2));
    }
}

export default AdvancedPentestingToolkit;
