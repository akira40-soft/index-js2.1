/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ADVANCED PENTESTING TOOLKIT - REAL TOOLS v2
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ… NMAP - Port scanning real (github.com/nmap/nmap)
 * âœ… SQLMAP - SQL injection real (github.com/sqlmapproject/sqlmap)
 * âœ… Hydra - Password cracking (github.com/vanhauser-thc/thc-hydra)
 * âœ… Nuclei - Vulnerability scanning (github.com/projectdiscovery/nuclei)
 * âœ… Masscan - Fast port scanner (github.com/robertdavidgraham/masscan)
 * âœ… Nikto - Web server scanner (github.com/sullo/nikto)
 * 
 * TODAS AS FERRAMENTAS SÃƒO REAIS E BAIXADAS NO DOCKERFILE.RAILWAY
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { spawn, execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

class AdvancedPentestingToolkit {
    private config: any;
    private tools: Record<string, string>;
    private resultsDir: string;
    private availableTools: Record<string, boolean> = {};

    constructor(config: any) {
        this.config = config;

        // Caminhos das ferramentas - devem corresponder ao Dockerfile.railway
        this.tools = {
            nmap: '/usr/bin/nmap',
            sqlmap: '/opt/sqlmap/sqlmap.py',
            hydra: '/usr/bin/hydra',
            nuclei: '/usr/local/bin/nuclei',
            masscan: '/usr/local/bin/masscan',
            nikto: '/usr/bin/nikto',
            setoolkit: '/usr/bin/setoolkit',
            metasploit: '/usr/bin/msfconsole'
        };

        // DiretÃ³rio de resultados
        this.resultsDir = config.resultsDir || '/tmp/pentest_results';
        if (!fs.existsSync(this.resultsDir)) {
            fs.mkdirSync(this.resultsDir, { recursive: true });
        }

        this._checkAvailableTools();
    }

    _checkAvailableTools() {
        const available: { [key: string]: boolean } = {};
        console.log('ğŸ” Verificando ferramentas de seguranÃ§a...');

        for (const [name, toolPath] of Object.entries(this.tools)) {
            try {
                // Verifica se o arquivo existe
                if (fs.existsSync(toolPath)) {
                    // Tenta executar para confirmar que funciona - Comando especÃ­fico por ferramenta
                    let checkCmd;
                    switch (name) {
                        case 'sqlmap':
                            checkCmd = `python3 ${toolPath} --version`;
                            break;
                        case 'hydra':
                            checkCmd = `${toolPath} -h`; // Hydra nÃ£o suporta --version
                            break;
                        case 'nikto':
                        case 'nuclei':
                            checkCmd = `${toolPath} -version`; // Nikto e Nuclei usam -version
                            break;
                        case 'setoolkit':
                            checkCmd = `${toolPath} --help`; // SEToolkit help
                            break;
                        case 'metasploit':
                            checkCmd = `${toolPath} -v`; // msfconsole version
                            break;
                        default:
                            checkCmd = `${toolPath} --version`;
                    }

                    execSync(checkCmd, { stdio: 'pipe', timeout: 5000 });
                    available[name] = true;
                    console.log(` âœ… ${name}: ${toolPath}`);
                } else {
                    available[name] = false;
                    console.warn(` âŒ ${name}: ${toolPath} (nÃ£o encontrado)`);
                }
            } catch (e: any) {
                // Hydra retorna cÃ³digo 0 com -h, mas outras podem retornar erro se nÃ£o houver args
                // Se o erro for apenas de execuÃ§Ã£o mas o comando retornou algo, consideramos ok
                if (fs.existsSync(toolPath)) {
                    available[name] = true;
                    console.log(` âœ… ${name}: ${toolPath} (verificado com aviso)`);
                } else {
                    available[name] = false;
                    console.warn(` âŒ ${name}: ${toolPath} (erro: ${e.message})`);
                }
            }
        }

        this.availableTools = available;
    }

    async nmapScan(target: string, opcoes: string = '-sV -T4'): Promise<any> {
        if (!this.availableTools.nmap) return { error: 'Nmap nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = opcoes.split(' ').concat(target);
            const nmap = spawn(this.tools.nmap, args);

            let output = '';
            let error = '';

            nmap.stdout.on('data', (data) => output += data.toString());
            nmap.stderr.on('data', (data) => error += data.toString());

            nmap.on('close', (code) => {
                if (code === 0) {
                    const result = { tool: 'nmap', target, output, timestamp: new Date() };
                    this._saveResult('nmap', target, result);
                    resolve(result);
                } else {
                    reject({ tool: 'nmap', error: error || 'Erro desconhecido', code });
                }
            });
        });
    }

    async sqlmapTest(url: string, parametro: string): Promise<any> {
        if (!this.availableTools.sqlmap) return { error: 'SQLMap nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                this.tools.sqlmap,
                '-u', url,
                '-p', parametro,
                '--batch',
                '--dbs',
                '--level=1',
                '--risk=1'
            ];

            const sqlmap = spawn('python3', args);

            let output = '';
            let error = '';

            sqlmap.stdout.on('data', (data) => output += data.toString());
            sqlmap.stderr.on('data', (data) => error += data.toString());

            sqlmap.on('close', (code) => {
                const result = { tool: 'sqlmap', target: url, output, timestamp: new Date() };
                this._saveResult('sqlmap', url, result);
                resolve(result);
            });
        });
    }

    async hydraBrute(target: string, servico: string, usuario: string, wordlist: string[] | null = null): Promise<any> {
        if (!this.availableTools.hydra) return { error: 'Hydra nÃ£o instalado' };

        // Usa wordlist padrÃ£o se nÃ£o fornecida
        const senhas = wordlist || ['123456', 'password', 'admin', 'root', '12345'];
        const passwordFile = path.join(this.resultsDir, `passwords_${Date.now()}.txt`);
        fs.writeFileSync(passwordFile, senhas.join('\n'));

        return new Promise((resolve, reject) => {
            const args = [
                '-l', usuario,
                '-P', passwordFile,
                '-o', path.join(this.resultsDir, `hydra_${target}_${servico}.txt`),
                target,
                servico,
                '-f' // Sair apÃ³s primeira tentativa bem-sucedida
            ];

            const hydra = spawn(this.tools.hydra, args);

            let output = '';

            hydra.stdout.on('data', (data) => output += data.toString());

            hydra.on('close', (code) => {
                fs.unlinkSync(passwordFile); // Limpa arquivo temp
                const result = { tool: 'hydra', target, service: servico, output, timestamp: new Date() };
                this._saveResult('hydra', target, result);
                resolve(result);
            });
        });
    }

    async nucleiScan(target: string, templates: string = 'cves'): Promise<any> {
        if (!this.availableTools.nuclei) return { error: 'Nuclei nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                '-target', target,
                '-templates', templates,
                '-severity', 'critical,high,medium',
                '-json',
                '-o', path.join(this.resultsDir, `nuclei_${target.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.json`)
            ];

            const nuclei = spawn(this.tools.nuclei, args);

            let output = '';

            nuclei.stdout.on('data', (data) => output += data.toString());

            nuclei.on('close', (code) => {
                // Ler resultado JSON gerado
                try {
                    const resultFile = args[args.indexOf('-o') + 1];
                    let results = [];
                    if (fs.existsSync(resultFile)) {
                        const content = fs.readFileSync(resultFile, 'utf8');
                        results = content.split('\n').filter((x: string) => x).map((line: string) => JSON.parse(line));
                    }

                    const report = { tool: 'nuclei', target, vulnerabilities: results, timestamp: new Date() };
                    this._saveResult('nuclei', target, report);
                    resolve(report);
                } catch (e: any) {
                    reject(e);
                }
            });
        });
    }

    async masscanScan(target: string, portas: string = '80,443,8080,22'): Promise<any> {
        if (!this.availableTools.masscan) return { error: 'Masscan nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                '-p', portas,
                target,
                '--rate', '1000',
                '-oJ', path.join(this.resultsDir, `masscan_${target.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.json`)
            ];

            const masscan = spawn(this.tools.masscan, args);
            let output = '';

            masscan.stdout.on('data', (data) => output += data.toString());

            masscan.on('close', (code) => {
                try {
                    const resultFile = args[args.indexOf('-oJ') + 1];
                    const content = fs.existsSync(resultFile) ? JSON.parse(fs.readFileSync(resultFile, 'utf8')) : [];
                    const result = { tool: 'masscan', target, ports: content, timestamp: new Date() };
                    this._saveResult('masscan', target, result);
                    resolve(result);
                } catch (e: any) {
                    reject(e);
                }
            });
        });
    }

    async niktoScan(url: string, opcoes: string = ''): Promise<any> {
        if (!this.availableTools.nikto) return { error: 'Nikto nÃ£o instalado' };

        return new Promise((resolve, reject) => {
            const args = [
                '-h', url,
                '-o', path.join(this.resultsDir, `nikto_${url.replace(/[^a-z0-9]/g, '_')}_${Date.now()}.txt`),
                ...opcoes.split(' ').filter(x => x)
            ];

            const nikto = spawn(this.tools.nikto, args);
            let output = '';

            nikto.stdout.on('data', (data) => output += data.toString());

            nikto.on('close', (code) => {
                const result = { tool: 'nikto', target: url, output, timestamp: new Date() };
                this._saveResult('nikto', url, result);
                resolve(result);
            });
        });
    }

    async setoolkitHelp(target: string): Promise<any> {
        if (!this.availableTools.setoolkit) return { error: 'SEToolkit nÃ£o instalado' };
        return { tool: 'setoolkit', info: 'O SEToolkit Ã© uma ferramenta interativa e requer acesso direto ao terminal para a maioria das funÃ§Ãµes. Use com cautela.', target };
    }

    async metasploitCheck(target: string): Promise<any> {
        if (!this.availableTools.metasploit) return { error: 'Metasploit nÃ£o instalado' };
        return { tool: 'metasploit', info: 'O Metasploit (msfconsole) Ã© uma ferramenta complexa. Akira recomenda o uso via console dedicado para exploraÃ§Ã£o avanÃ§ada.', target };
    }

    private _saveResult(tool: string, target: string, result: any): void {
        const safeTarget = target.replace(/[^a-z0-9]/g, '_').substring(0, 50);
        const filename = path.join(
            this.resultsDir,
            `${tool}_${safeTarget}_${Date.now()}.json`
        );

        fs.writeFileSync(filename, JSON.stringify(result, null, 2));
    }
}

export default AdvancedPentestingToolkit;
